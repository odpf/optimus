package github

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"runtime"
	"strings"

	"github.com/odpf/optimus/extension"
)

const provider = "github"

// Client defines github client
type Client struct {
	ctx      context.Context //nolint:containedctx
	httpdoer extension.HTTPDoer
}

// NewClient initializes github client
func NewClient(ctx context.Context, httpDoer extension.HTTPDoer) (*Client, error) {
	if ctx == nil {
		return nil, extension.ErrNilContext
	}
	if httpDoer == nil {
		return nil, extension.ErrNilHTTPDoer
	}
	return &Client{
		ctx:      ctx,
		httpdoer: httpDoer,
	}, nil
}

// DownloadRelease downloads a release based on the API path
func (c *Client) DownloadRelease(apiPath string) (*extension.RepositoryRelease, error) {
	if apiPath == "" {
		return nil, extension.ErrEmptyAPIPath
	}
	request, err := http.NewRequestWithContext(c.ctx, "GET", apiPath, http.NoBody)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}
	request.Header.Set("Accept", "application/json")

	response, err := c.httpdoer.Do(request)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	defer response.Body.Close()
	if response.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("unexpected status response: %s", response.Status)
	}

	var release Release
	decoder := json.NewDecoder(response.Body)
	if err := decoder.Decode(&release); err != nil {
		return nil, fmt.Errorf("error decoding response: %w", err)
	}
	return release.toRepositoryRelease(apiPath), nil
}

// DownloadAsset downloads github asset based on the asset api path.
// Currently, it can only download asset from publicly available repository.
// `apiPath` follows prefix [https://api.github.com/repos], which can be
// generated by this provider parser. For more information,
// check [this](https://docs.github.com/en/rest/releases/releases) documentation.
func (c *Client) DownloadAsset(apiPath string) ([]byte, error) {
	if apiPath == "" {
		return nil, extension.ErrEmptyAPIPath
	}
	release, err := c.DownloadRelease(apiPath)
	if err != nil {
		return nil, fmt.Errorf("error getting repository release: %w", err)
	}
	assetURL, err := c.getAssetURL(release)
	if err != nil {
		return nil, fmt.Errorf("error getting asset URL: %w", err)
	}
	return c.downloadAsset(assetURL)
}

func (c *Client) downloadAsset(url string) ([]byte, error) {
	request, err := http.NewRequestWithContext(c.ctx, "GET", url, http.NoBody)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}
	request.Header.Set("Accept", "application/octet-stream")

	response, err := c.httpdoer.Do(request)
	if err != nil {
		return nil, fmt.Errorf("error getting release asset: %w", err)
	}
	defer response.Body.Close()

	return io.ReadAll(response.Body)
}

func (c *Client) getAssetURL(release *extension.RepositoryRelease) (string, error) {
	suffix := c.getDistSuffix()
	for _, asset := range release.Assets {
		if strings.HasSuffix(asset.Name, suffix) {
			return asset.URL, nil
		}
	}
	return "", fmt.Errorf("asset with suffix [%s] is not found", suffix)
}

func (*Client) getDistSuffix() string {
	return runtime.GOOS + "-" + runtime.GOARCH
}

func init() { //nolint:gochecknoinits
	if err := extension.NewClientRegistry.Add(provider,
		func(ctx context.Context, httpDoer extension.HTTPDoer) (extension.Client, error) {
			return NewClient(ctx, httpDoer)
		},
	); err != nil {
		panic(err)
	}
}
